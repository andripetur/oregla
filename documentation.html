<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title> (ó)regla documentation </title>
        <link rel="icon" href="imgs/icon.png">

        <link rel="stylesheet" href="style.css"/>
        <script src="https://code.jquery.com/jquery-2.2.3.min.js" integrity="sha256-a23g1Nt4dtEYOj7bR+vTu7+T8VP13humZFBJNIYoEJo=" crossorigin="anonymous"></script>
    </head>

    <body class=docBody>
      <div id='title' style="width: 24%;"><br>(ó)regla<br>&nbsp;</div>
      <div id='docNav' class="jqconsole" style="padding-top: 100px;"> <ul> </ul> </div>
      <div id='docContent' class="jqconsole">
        <section id='about'>
          <h1> About (ó)regla </h1>
            <p> (ó)regla is an interactive live coding environment. Intended do showcase the power of an algorithmic approach to composition, utilizing chaotic systems to generate melodic content, and Schillingers approach to generating rhythms. Through the command console you can generate, modify and the sound and sequences.
            (ó)regla is in active developement, so it is still fluid in terms of interface and available features.</p>
        <section id='chaos'>
          <h1> Chaos </h1>
            <p>  Chaos is not random but deterministic. If you run a formula a hundred times with the same parameters, you get the same output every time. Chaos theory is a part of a math subject called dynamics, which deals with change and systems that evolve in time. The way a chaotic system constantly evolves, is by feeding back the output of the first iteration into the second, creating a non-linear feedback system. Although the output of chaos may appear random, if observed from a distance, patterns begin to emerge. </p>
        </section>
        <section id='sound'>
          <h1> Sound </h1>
            <p> The (ó)regla sound engine is powered by <a class="docLink" href="https://github.com/colinbdclark/flocking">flocking.js</a>, a creative audio synthesis framework built ontop of the webaudio API.
        </section>
      </section>

      <section id="compose">
        <h1> Composition </h1>
          <p> Let's compose! To get started we need to generate some content to work with. Lets fill a "buffer" with iterations of a chaotic functions. <code>instrument.fillChaosBuffer()</code>. Then to hear the contents of the buffer we have map the contents of the buffer too melodic content, <code>instrument.mapBufferToNotes()</code>.  Nnow we just need some rhythm to get the groove going, either do <code>instrument.mapBufferToRhythm()</code> to map the chaos to rhythm as well, or genarate a rhythm using schillingers intereference of monomials ala: <code>instrument.newRhythm('fast', [2,3])</code>. Now type in <code>instrument.start()</code> and you'll hear a musical phrase!</p>
        <section id='scales'>
          <h1> Scales </h1>
            <p> There are number of scales to choose from. You can create your own or use one of the scales that come outof the box and you can ofcourse also choose to not adhere to any of them.
            <ul>
              <li> ionian </li>
              <li> dorian </li>
              <li> phrygian </li>
              <li> lydian </li>
              <li> mixolydian </li>
              <li> aeolian </li>
              <li> locrian </li>
              <li> none </li>
          </ul> </p>
        </section>
          <section id='time'>
            <h1> Time </h1>
              <p> When you want an element to transition from a state to another for x amount of time, or when specifying time signatures and such, it's handy not having to muck around with seconds and minutes like caveman. Instead we'll use this handy time value syntax. The note value abbreviations mirror the MAX MSP timing syntax, but that's where the similarity ends. When specifying time length in bars, it's as simple as barlength + b. Barlength can be both a whole number and a fraction. So one bar is <b>1b</b>, and one and a half bar is <b>1.5b</b> and etc.
              <ul>
                <li><b>1nd</b> - Dotted whole note</li>
                <li><b>1n</b> - Whole note</li>
                <li><b>1nt</b> - Whole note triplet</li>
                <li><b>2nd</b> - Dotted half note</li>
                <li><b>2n</b> - Half note</li>
                <li><b>2nt</b> - Half note triplet</li>
                <li><b>4nd</b> - Dotted quarter note</li>
                <li><b>4n</b> - Quarter note</li>
                <li><b>4nt</b> - Quarter note triplet</li>
                <li><b>8nd</b> - Dotted eighth note</li>
                <li><b>8n</b> - Eighth note</li>
                <li><b>8nt</b> - Eighth note triplet</li>
                <li><b>16nd</b> - Dotted sixteenth note</li>
                <li><b>16n</b> - Sixteenth note</li>
                <li><b>16nt</b> - Sixteenth note triplet</li>
                <li><b>32nd</b> - Dotted thirty-second note</li>
                <li><b>32n</b> - thirty-second note</li>
                <li><b>32nt</b> - thirty-second-note triplet</li>
                <li><b>64nd</b> - Dotted sixty-fourth note</li>
                <li><b>64n</b> - Sixty-fourth note</li> </br>
                <li><b>1b</b> - One bar</li>
                <li><b>2b...99b</b> - Two bars...ninety-nine bars</li>
                <li><b>100b</b> - One hundred bars</li>
            </ul> </p>
            <p>If you are one of the cool cats who likes to micromanage, and would rather like to do time conversions by hand you can type your desired amount and appending 'm' for minutes, 's' for seconds or 'ms' for milliseconds.
              <ul>
                <li><b>1m</b> - One minute</li>
                <li><b>60s</b> - Sixty seconds</li>
                <li><b>60000ms</b> - Sixty-thousand milliseconds</li>
            </ul></p>
          </section>
          <section id=generators>
            <h1> Generators </h1>
            <p><b>fillChaosBuffer</b> </br></p>
            <p><b>newRhythm</b> </br></p>
          </section>
          <section id=modifiers>
            <h1> Modifiers </h1>

            <p><b>reverse</b> </br>
              If called without an argument this function Reverses both the notes and rhythm. But you can call it with an argument, choosing which to reverse: notes or rhythm. </p>
            <p><b>multiplyIntervals</b> </br>
              Multiplies all note intervals with given argument 1, transforming it into a new melody.</p>
            <p><b>transpose</b> </br>
              Transpose all notes by amount given in argument 1.
            <p><b>clampToRange</b> </br>
              Rearrange the notes, so they keep the same note value, but the octave is shifted until the note falls in the into the given note range.
            </p>
            <p><b>mirrorNotes</b> </br>
              Mirror the note values, so that the heighest becomes the lowest, the lowest highest and etc.
            </p>
            <p><b>mirrorIntervals</b> </br>
              Mirror the note intervals, so that the heighest becomes the lowest, the lowest highest and etc.
            </p>
            <p><b>mirrorRhythm</b> </br>
              Mirror the rhytmic intervals, so that the heighest becomes the lowest, the lowest highest and etc.
            </p>
          </section>
        </section>

       </div>

       <script>
       $(document).ready(function() {
         var getPageOffset = function() {
           var doc = document.documentElement;
           return (window.pageYOffset || doc.scrollTop)  - (doc.clientTop || 0);
         }
         $('#docContent section').each(function(index){
           var link = window.location.pathname + '#'+this.id;
           $('#docNav').first().append( '<li> <a href=' + link + '>' + this.id + '</a></li>' );
         });

         var docNavPlaceMent = (window.innerWidth*0.75);
         var maxHeight = document.body.scrollHeight - docNavPlaceMent;
         var longPos = 0;
         var scrollEventCounter = 0;

         setTimeout(function () { // scroll into view if we start at an offset
           $('#docNav').css( 'top' , getPageOffset );
          }, 10);

         $( window ).scroll(function(scrll) {
           var top = getPageOffset();
           var currPos = parseInt($('#docNav').css('top').replace('px',''));
           longPos += currPos;
           longPos = longPos/2;

           if( scrollEventCounter % 5 == 4){ // dont react on every scroll event
             if( longPos > maxHeight ) {
               $('#docNav').css( 'top' , maxHeight );
             } else {
               $('#docNav').css( 'top' , top );
             }
           }
           scrollEventCounter++;
          });
        });
       </script>
    </body>
</html>
